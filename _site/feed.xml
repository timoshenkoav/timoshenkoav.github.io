<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alex&#39;s Blog</title>
    <description></description>
    <link>http://blog.tunebrains.com/</link>
    <atom:link href="http://blog.tunebrains.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 28 Oct 2015 15:18:56 +0100</pubDate>
    <lastBuildDate>Wed, 28 Oct 2015 15:18:56 +0100</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Signing android app for secure content provider</title>
        <description>&lt;p&gt;Always was curious how to manage android keystore sertificates for multiple apps, either generate separate keystore file each time, or just use multiple alias in the same keystore.&lt;/p&gt;

&lt;p&gt;Now its time to make it clear.&lt;/p&gt;

&lt;p&gt;To make it clear, i&lt;code&gt;ve created sample app with multiple flavours. Each flavour can be installed on device, and they does not run in the same process, so fingerprint of keystored should be different, can we do this using aliases? Lets check. To make sure everything works, i&lt;/code&gt;ll use secured content provider based on signature level verification&lt;/p&gt;

&lt;p&gt;Flavors config:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;productFlavors {
    flavor2 {
        applicationId &amp;#39;com.tunebrains.keystoresample2&amp;#39;
        versionName &amp;#39;10&amp;#39;
    }
    flavor1 {
        applicationId &amp;#39;com.tunebrains.keystoresample1&amp;#39;
        versionName &amp;#39;10&amp;#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Generate our keystore with multiple aliases:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;keytool -genkey -v -keystore release_key.keystore -alias flavor1 -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Add another alias to the keystore&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;keytool -genkey -v -keystore release_key.keystore -alias flavor2 -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Configure two signing configs:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;signingConfigs {
    Flavor1 {
        storeFile file(&amp;quot;release_key.keystore&amp;quot;)
        storePassword &amp;quot;password&amp;quot;
        keyAlias &amp;quot;flavor1&amp;quot;
        keyPassword &amp;quot;password1&amp;quot;
    }
    Flavor2 {
        storeFile file(&amp;quot;release_key.keystore&amp;quot;)
        storePassword &amp;quot;password&amp;quot;
        keyAlias &amp;quot;flavor2&amp;quot;
        keyPassword &amp;quot;password2&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Configure release signing for both flavors:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;productFlavors {
    flavor1 {
        applicationId &amp;#39;com.tunebrains.keystoresample1&amp;#39;
        versionName &amp;#39;10&amp;#39;        
        signingConfig signingConfigs.Flavor1
    }
    flavor2 {
        applicationId &amp;#39;com.tunebrains.keystoresample2&amp;#39;
        versionName &amp;#39;10&amp;#39;        
        signingConfig signingConfigs.Flavor2
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each flavor has its own content provider, which is secured by signature level permission&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;permission android:name=&amp;quot;${applicationId}.permission&amp;quot;
                android:protectionLevel=&amp;quot;signature&amp;quot;/&amp;gt;
&amp;lt;provider
    android:exported=&amp;quot;true&amp;quot;
    android:authorities=&amp;quot;${applicationId}.provider&amp;quot;
    android:name=&amp;quot;.ContentProviderSecured&amp;quot;
    android:permission=&amp;quot;${applicationId}.permission&amp;quot;&amp;gt;
&amp;lt;/provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Code for content provider is quite simple, it just return empty &lt;strong&gt;MatrixCursor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    MatrixCursor lMatrixCursor = new MatrixCursor(new String[]{&amp;quot;key&amp;quot;});    
    return lMatrixCursor;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Flavor2 will try to get access to Flavor1 content provider&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Cursor c = null;
try {
    c = getContentResolver().query(Uri.parse(&amp;quot;content://&amp;quot; + &amp;quot;com.tunebrains.keystoresample1&amp;quot; + &amp;quot;/query&amp;quot;), null, null, null, null);
    Log.d(&amp;quot;Result&amp;quot;, &amp;quot;&amp;quot; + c.getCount());
}catch (Exception e){
    Log.d(&amp;quot;Result&amp;quot;, &amp;quot;Cannot access provider&amp;quot;);
}finally {
    if (c!=null){
        c.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now its time to install both apps, and check if Flavor2 does NOT have access to Flavor1 data. And its true, everything works well as expected. To get access to Flavor1 data from Flavor2 we need to sign it with &lt;strong&gt;Flavor2&lt;/strong&gt; signingConfig.&lt;/p&gt;

&lt;p&gt;Code is available on &lt;a href=&quot;https://github.com/timoshenkoav/KeystoreSample&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Oct 2015 14:17:35 +0100</pubDate>
        <link>http://blog.tunebrains.com/2015/10/28/make-clear-android-signing-and-content-provider.html</link>
        <guid isPermaLink="true">http://blog.tunebrains.com/2015/10/28/make-clear-android-signing-and-content-provider.html</guid>
        
        <category>android</category>
        
        <category>keystore</category>
        
        
      </item>
    
      <item>
        <title>Android UsageStatsManager sample</title>
        <description>&lt;p&gt;Google has deprecated the function &amp;quot;getRecentTasks&amp;quot; of &amp;quot;ActivityManager&amp;quot; class. Now all it does is to get the list of apps that the current app has opened. But if you are writing app that &amp;quot;locks&amp;quot; access to specific apps with password or any other protection methods, you still need to be able to get top most activity/package to react accordingly to user changing current app and for example show your overlay.&lt;/p&gt;

&lt;p&gt;Google introduces UsageStatsManager in api 21, which can replace &amp;quot;getRecentTasks&amp;quot; for new versions.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ve created sample project demonstrating how to use this api.&lt;/p&gt;

&lt;p&gt;First of all you need to declare permission in AndroidManifest.xml&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.PACKAGE_USAGE_STATS&amp;quot;
                     tools:ignore=&amp;quot;ProtectedPermissions&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Adding  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tools:ignoe=&amp;quot;ProtectedPermissions&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will disable warning that permission is system level and will not be granted to third-party apps. However, declaring the permission implies intention to use the API and the user of the device can grant permission through the Settings application.&lt;/p&gt;

&lt;p&gt;So we need to check if our app was granted this permission&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private boolean hasPermission() {
    AppOpsManager appOps = (AppOpsManager)
                getSystemService(Context.APP_OPS_SERVICE);
    int mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,
            android.os.Process.myUid(), getPackageName());
    return mode == AppOpsManager.MODE_ALLOWED;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and if no, ask user to enable it&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;startActivityForResult(
    new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS), 
        MY_PERMISSIONS_REQUEST_PACKAGE_USAGE_STATS);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We are launching settings activity to allow app to get usage stats, its not android M default way to deal with permissions, we need to check result in onActivityResult&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode){
        case MY_PERMISSIONS_REQUEST_PACKAGE_USAGE_STATS:
            if (hasPermission()){
                getStats();
            }else{
                requestPermission();
            }
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this sample if user did not grant permission we will ask again while permission is not granted. In real application, its better to tell user why do we need this permission and turn off functionality if permission was not granted.&lt;/p&gt;

&lt;p&gt;After the permission was eventually granted, we can query information about last active packages&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;UsageStatsManager lUsageStatsManager = 
    (UsageStatsManager) getSystemService(Context.USAGE_STATS_SERVICE);
List&amp;lt;UsageStats&amp;gt; lUsageStatsList = 
    lUsageStatsManager.queryUsageStats(
        UsageStatsManager.INTERVAL_DAILY, 
        System.currentTimeMillis()- TimeUnit.DAYS.toMillis(1),
        System.currentTimeMillis()+ TimeUnit.DAYS.toMillis(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are a lot of methods in UsageStatsManager, that can be usefull for your app. Checkout &lt;a href=&quot;https://developer.android.com/reference/android/app/usage/UsageStatsManager.html&quot;&gt;official documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Full source code for this article is available on &lt;a href=&quot;https://github.com/timoshenkoav/USMSample&quot;&gt;GitHub&lt;/a&gt; &lt;/p&gt;
</description>
        <pubDate>Tue, 20 Oct 2015 19:41:00 +0200</pubDate>
        <link>http://blog.tunebrains.com/2015/10/20/usage-stats-manager-sample.html</link>
        <guid isPermaLink="true">http://blog.tunebrains.com/2015/10/20/usage-stats-manager-sample.html</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Encrypted API from android to rails</title>
        <description>&lt;p&gt;Working on remote logging system for android, I faced up with Google require not to send user information to remote system, as this violates section 4.3 of the Developer Distribution Agreement.&lt;/p&gt;

&lt;p&gt;To solve this we need to send the data to our server encrypted.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s nice to encrypt it so even if someone sniff the traffic they will not be able to decrypt contents.&lt;/p&gt;

&lt;p&gt;To provide such encryption we can use asymmetric algorithm like RSA, public key is stored inside the android application and used to encrypt the data sent to remote server, private key is stored on servicer side and used to decrypt the data.&lt;/p&gt;

&lt;p&gt;But the problem with asymmetric algorithm is that generaly they can encrypt data length up to key size, so for RSA its 4096 bits, which is not good in our case, as our logs can be much longer.&lt;/p&gt;

&lt;p&gt;Symmetric algorithms, like AES can encrypt practically unlimited ammount of data, but as the same key is used to encrypt and decrypt information, it&amp;#39;s easy to stole data while transmissing to server if one has access to app code, which is true for Android applications. &lt;/p&gt;

&lt;p&gt;The often used solution is:&lt;/p&gt;

&lt;p&gt;On Client Side:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Generate random AES key ( e.g 256 bits long)&lt;/li&gt;
&lt;li&gt;Encrypt body with AES using generated key&lt;/li&gt;
&lt;li&gt;Encrypt key with RSA using stored public key&lt;/li&gt;
&lt;li&gt;Send encrypted key along with encrypted body&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On Server Side&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Decrypt key with RSA private key to get plain AES key&lt;/li&gt;
&lt;li&gt;Decrypt body with plain AES key&lt;/li&gt;
&lt;li&gt;Handle the request&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets start from the client side:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Generate random AES key&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static final int AES_KEY_SIZE = 256 / 8;
public static String randomKey(int len) {
    Random generator = new Random();
    StringBuilder randomStringBuilder = new StringBuilder();
    int randomLength = len;
    char tempChar;
    for (int i = 0; i &amp;lt; randomLength; i++) {
        tempChar = (char) (generator.nextInt(96) + 32);
        randomStringBuilder.append(tempChar);
    }
    return randomStringBuilder.toString();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt data with AES&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static byte[] AESEncrypt(final String plain, String pKey) throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException {

    SecretKeySpec skeySpec = new SecretKeySpec(pKey.getBytes(), &amp;quot;AES&amp;quot;);
    Cipher cipher = Cipher.getInstance(&amp;quot;AES&amp;quot;);
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(plain.getBytes());
    return encrypted;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt key using RSA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To generate RSA key-pair we can simply use great online service: &lt;a href=&quot;http://travistidwell.com/jsencrypt/demo/&quot;&gt;Generate Key Online&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can store public key either in assets/resources/plain string&lt;/p&gt;

&lt;p&gt;To unify reading key we can use InputStream as source, so it can be FileInputStream, ByteArrayInputStream or any other source:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static byte[] readKeyWrapped(InputStream pInputStream) throws IOException {
    String lStringKey = read(pInputStream);
    String lRawString = stripKeyHeaders(lStringKey);
    return base64(lRawString);
}
public static String stripKeyHeaders(String key) {
    StringBuilder strippedKey = new StringBuilder();
    String lines[] = key.split(&amp;quot;\n&amp;quot;);
    for (String line : lines) {
        if (!line.contains(&amp;quot;PRIVATE KEY&amp;quot;) &amp;amp;&amp;amp; !line.contains(&amp;quot;PUBLIC KEY&amp;quot;) &amp;amp;&amp;amp; !TextUtils.isEmpty(line.trim())) {
            strippedKey.append(line.trim());
        }
    }
    return strippedKey.toString().trim();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using public key, we can encrypt data&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static byte[] RSAEncrypt(final byte[] plain, byte[] pKey) throws NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException, InvalidKeySpecException, InvalidKeyException {
    X509EncodedKeySpec spec = new X509EncodedKeySpec(pKey);
    KeyFactory kf = KeyFactory.getInstance(&amp;quot;RSA&amp;quot;);
    PublicKey publicKey = kf.generatePublic(spec);
    Cipher cipher = Cipher.getInstance(&amp;quot;RSA/ECB/PKCS1Padding&amp;quot;);
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte []encryptedBytes = cipher.doFinal(plain);
    return encryptedBytes;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we have everything encrypted and we can send data to our API. Body will be send as base64 request body, encrypted key - as request header.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;byte[] lRSAKey = readKeyWrapped(getResources().openRawResource(R.raw.api_public));
String lAESKey =  randomKey(AES_KEY_SIZE);      
String lEncryptedKey = Base64.encode(RSAEncrypt(lAESKey, lAESKey), 0);
String lEncryptedBody = Base64.encode(AESEncrypt(body, lAESKey), 0);
post(&amp;quot;http://api-domain.com&amp;quot;, lEncryptedBody, lEncryptedKey);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To Be Continued...&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Oct 2015 19:54:00 +0200</pubDate>
        <link>http://blog.tunebrains.com/2015/10/02/android-encrypted-api-with-rails.html</link>
        <guid isPermaLink="true">http://blog.tunebrains.com/2015/10/02/android-encrypted-api-with-rails.html</guid>
        
        <category>android</category>
        
        <category>rails</category>
        
        
      </item>
    
      <item>
        <title>Sign multiple flavors with different keystores</title>
        <description>&lt;p&gt;One of my projects has a lot of flavors, and each flavor has different keystore to sign with. As a result it has very long build.gradle project file. As each flavor need defining separate singningConfig and defining flavor signing on release buildType&lt;/p&gt;

&lt;p&gt;After reading couple of articles, i end up with this solution:&lt;/p&gt;

&lt;p&gt;Create &lt;code&gt;signs.gradle&lt;/code&gt; under project folder:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def fillDefaults(signingConfig) {
    signingConfig.storeFile = null
    signingConfig.storePassword = &amp;#39;&amp;#39;
    signingConfig.keyAlias = &amp;#39;&amp;#39;
    signingConfig.keyPassword = &amp;#39;&amp;#39;
}
def setupSigning(name) {
    def signingProperties = &amp;quot;${name}.info&amp;quot;
    def signingKeys = [
            storeFile    : { x -&amp;gt; file(x) },
            storePassword: { x -&amp;gt; x },
            keyAlias     : { x -&amp;gt; x },
            keyPassword  : { x -&amp;gt; x },
    ]
    // Find signing.properties in project root, or in $HOME/.gradle
    def f = [&amp;quot;${projectDir}/certs/${signingProperties}&amp;quot;].find { file(it).exists() }
    if (f) {
        println &amp;quot;Loading signing properties from ${f}&amp;quot;
        def props = new Properties()
        props.load(new FileInputStream(f))

        // For each property apply it to the release signing config
        signingKeys.any { k, fn -&amp;gt;
            if (!props.containsKey(k)) {
                println &amp;quot;Missing property ${k}&amp;quot;
                fillDefaults(android.signingConfigs[name])
                return true
            } else {
                android.signingConfigs[name][k] = fn(props[k]);
            }
            return
        }
        println android.signingConfigs[name]
    } else {
        println &amp;quot;Missing ${signingProperties} file&amp;quot;
        fillDefaults(android.signingConfigs[name])
    }
}
ext {
    setupSigning = this.&amp;amp;setupSigning
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Apply it in project &lt;code&gt;build.gradle&lt;/code&gt; in the beggining of the file&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;apply from: &amp;#39;signs.gradle&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Add callbacks when &lt;code&gt;signingConfigs&lt;/code&gt; and &lt;code&gt;productFlavors&lt;/code&gt; is added:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android.signingConfigs.whenObjectAdded { signing -&amp;gt;
    setupSigning(signing.name)
}

android.productFlavors.whenObjectAdded { flavor -&amp;gt;
    flavor.signingConfig = android.signingConfigs[flavor.name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first will call our function with added signing name&lt;/p&gt;

&lt;p&gt;The second will set &lt;code&gt;signingConfig&lt;/code&gt; for flavor based on loaded config&lt;/p&gt;

&lt;p&gt;Keystore information is stored in files named &lt;code&gt;&amp;lt;flavor_name&amp;gt;.info&lt;/code&gt; under &lt;code&gt;certs&lt;/code&gt; folder under project subfolder. The format of this file is often used to storing `signed.properties&amp;#39;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;storeFile=certs/&amp;lt;filename&amp;gt;
storePassword=&amp;#39;&amp;#39;
keyAlias=&amp;#39;&amp;#39;
keyPassword=&amp;#39;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Usage&lt;/h2&gt;

&lt;p&gt;Add flavor configuration&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;productFlavors {
    app1 {    
        applicationId &amp;#39;com.sample.app1&amp;#39;   
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Register signing config with the same name as flavor&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;signingConfigs {
    app1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Create &lt;code&gt;app1.info&lt;/code&gt; file under &lt;code&gt;certs&lt;/code&gt; directory with information about the keystore.&lt;/p&gt;

&lt;p&gt;Build. Enjoy.&lt;/p&gt;

&lt;h2&gt;ToDo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Remove requirement to put &lt;code&gt;signingConfig&lt;/code&gt; with flavor name. It should do this automatically when flavor is registered&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://saulmm.github.io/squeezing-gradle-builds&quot;&gt;Squeezing your Gradle builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.robustastudio.com/mobile-development/android/building-multiple-editions-of-android-app-gradle/&quot;&gt;Building Multiple Editions of an Android App with Gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zserge.com/blog/android-signing.html&quot;&gt;HOW TO SIGN RELEASE APK WITH GRADLE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Oct 2015 13:11:35 +0200</pubDate>
        <link>http://blog.tunebrains.com/2015/10/02/gradle-multi-flavors-signing.html</link>
        <guid isPermaLink="true">http://blog.tunebrains.com/2015/10/02/gradle-multi-flavors-signing.html</guid>
        
        <category>android</category>
        
        <category>gradle</category>
        
        
      </item>
    
      <item>
        <title>Welcome</title>
        <description>&lt;div class=&#39;avatar&#39;&gt;
&lt;img src=&#39;https://gravatar.com/userimage/18991598/d52e7a5def139e3df3b98ab9ccf2b261.jpeg?size=500&#39;/&gt;
&lt;/div&gt;

&lt;p&gt;Having a lot of fun with work, i always store list of my achievements and new topics i am interested in &lt;strong&gt;Evernote&lt;/strong&gt; as a list, and information about them as notes. After almost a year using this technique i realized that is not so good way. Thats why i&amp;#39;ve created this blog on &lt;strong&gt;GitHub Pages&lt;/strong&gt; to check if its convenient for me to write articles (and as additional way to get some level up, as i haven&amp;#39;t wrote articles describing by life/work before) about my thoughts/work etc. &lt;/p&gt;

&lt;p&gt;Main purpose of this is to describe some technical things i learn,faced up while developing Android/RoR applications. But sometimes i will also post something about living in Montenegro. &lt;/p&gt;

&lt;p&gt;Lets have a fun!&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Oct 2015 13:11:34 +0200</pubDate>
        <link>http://blog.tunebrains.com/welcome/blog/2015/10/02/welcome.html</link>
        <guid isPermaLink="true">http://blog.tunebrains.com/welcome/blog/2015/10/02/welcome.html</guid>
        
        
        <category>welcome</category>
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
